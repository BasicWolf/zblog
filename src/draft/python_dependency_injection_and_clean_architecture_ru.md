= Domain-driven design, Clean architecture, Dependency injection и Python

 - Глянь, статью на Хабр подготовил.
\- Чувак, с таким заголовком уж лучше на английскую версию.
\- Предметно-ориентированное проектирование, Чистая архитектура, Внедрение зависимостей и Пайтон?
С пронзительным хлопком в воздухе материализуется обалдевший Сатана в обличии сине-жёлтого питона...

---

Полтора года назад я расстался с миром Python/Django и попал в мир
Kotlin/Spring Boot и Чистой Архитектуры.
Недавно нам понадобилось написать небольшую программу для внутренних
целей. Недолго заморачиваясь, я написал её на всё ещё любимом
Python. К моему удивлению и удовольствию, её удалось
написать примения вышеупомянутые практики
Предметно-ориентированного проектирования (Domain-driven design, DDD),
Чистой Архитектуры (Clean architecture) и
Внедрения зависимостей (Dependency Injection, DI).

Представляю на ваш суд технический рассказ о том, что такое
и как связаны между собой все вышеупомянутые темы.


== Пролог


Полтора года назад я сменил место работы и расставшись с миром Python/Django,
окунулся в мир Kotlin/Spring Boot.
Компания Abloy собирала команду для своего технологического авангарда.
Мы должны были помочь перенести её из прошлой механической
эры в эру цифрового будущего. Желание "делать качественно" поддерживалось на
всех уровнях менеджмента. Mы могли *творить* с чистого листа.

Муки выбора стека для бэкэнда были короткими:
двое джавистов против одного питониста не оставили места для манёвра.
Spring Boot в качестве фреймворка был выбран по той же причине.
В первые же дни работы мы попробовали Kotlin и к Java больше не возвращались.
Дальше пошло по накатаной: архитектура - ну а что мудрить, MVC.
Сделаем традиционные слои: бизнес-слой, контроллеры, персистентность...

**СТОП!**

Опять за старое?
Давайте потратим время на понимание предметной области.
Распишем истории пользователей (*User Story Mapping*).
Вникнем в практики DDD.
В конце концов почитаем, что умные люди говорят о надёжных архитектурных
решениях.

Прошло полтора года. Наше приложение стремительно растёт и усложняется.
Несмотря на это, его легко поддерживать, тестировать, развивать -
всё благодаря качественному фундаменту и архитектуре
Код получается выразительным и легковесным. Компоненты - легко заменяемыми.
Во всех отношениях это приложение качественнее всего написанного
нами в прошлом.

Недавно нашим железячникам понадобился CI-компонент для сборки, шифрования и
и выкладывания прошивок электронных замков на S3.
Я вызвался помочь с написанием, т.к. ребята немного знакомы с Python
(а основным рабочим инструментом у них служит bare-metal C).
Даже в таком маленьком приложении нам удалось
применить лучшие практики DDD и Чистой архитектуры.
Оглядываясь назад понимаю, что не смог бы написать *так* хорошо
опираясь лишь на старый опыт. И даже небольшие крупицы
знаний помогают программировать и решать проблемы бизнеса эффективнее.


== Dependency Injection

Вы знаете что такое Внедрение зависимости ака Dependency Injection (DI).
Точно знаете, хотя можете не вспомнить формальное определение.
Давайте на небольшом примере вспомним, в чём плюсы и минусы этого подхода
(или если вам угодно - шаблона).

Допустим нам понадобилась функция, отправляющая сообщения с пометкой "ТРЕВОГА!"
по шине сообщений. После недолгих размышлений мы написали:

```python
from my_cool_messaging_library import get_message_bus()

def send_alert(message: str):
    message_bus = get_message_bus()
    message_bus.send(topic='alert', message=message)
```

В чём главная проблема функции `send_alert()`?
Она зависит от объекта `message_bus`, но для вызывающего эта зависимость
совершенно не очевидна! А если вы хотите отправить ??? сообщение
по другой шине? Ась? А на закуску задумайтесь об уровне магии, необходимой
чтобы это протестировать. Что, что? `mock.patch(...)` говорите?
Коллеги, давайте попробуем зайти с другой стороны.

```python

  from my_cool_messaging_library import MessageBus

  def send_alert(message_bus: MessageBus, message: str):
      message_bus.send(topic='alert', message=message)
```

Казалось - небольшое изменение, добавили аргумент в функцию.
Но одним лишь этим изменением мы убиваем нескольких зайцев:
Вызывающему очевидно, что функция `send_alert()` **зависит**
от объекта `message_bus` типа `MessageBus` (да здравствуют аннотации!).
А тестирование, из обезьяньих патчей с бубном, превращается
в написание краткого и ясного кода. Не верите?

```python
#
def test_send_alert_sends_message_to_alert_topic()
    message_bus_mock = MessageBusMock()
    send_alert(message_bus_mock, "A week of astrology at Habrahabr!")

    assert message_bus_mock.sent_to_topic == 'alert'
    assert message_bus_mock.sent_message = message

class MessageBusMock(MessageBus):
    def send(self, topic, message):
        self.sent_to_topic = topic
        self.sent_message = message
```

Тут искушённый читатель задастся вопросом: неужели
придётся передавать экземпляр `message_bus` в функцию `send_alert()`
при каждом вызове? Но ведь это неудобно! В чём смысл каждый раз
писать

```python
send_alert(get_message_bus(), "Stackoverflow is down")
```

Давайте попытаемся решить эту проблему посредством ООП:

```python

class AlertDispatcher:
    _message_bus: MessageBus

    def __init__(self, message_bus: MessageBus):
        self._message_bus = message_bus

    def send(message: str):
        self._message_bus.send(topic='alert', message=message)

alert_dispatcher = AlertDispatcher(get_message_bus())
alert_dispatcher.send("Oh no, yet another dependency!")
```

Теперь уже класс `AlertDispatcher` **зависит** от объекта типа `MessageBus`.
Мы **внедряем** эту зависимость в момент создания объекта `AlertDispatcher`,
посредством передачи зависимости в метод `__init__()`. Мы **связали**
(we have **wired**, не путать с **coupling**!) объект и его зависимость.

Но теперь акцент смещается с `message_bus` на `alert_dispatcher`!
Этот **компонент** может понадобиться в различных местах приложения.
Мало ли откуда нужно оправить сигнал тревоги!
Значит, некоего глобального состояния не избежать.
В небольшом приложении программисту не составит труда управлять
парком из десятка зависимостей вручную. A что поделать, когда
приложение начнёт разрастаться до неприличных размеров?
И тут на сцену выходят Kонтейнеры инверсии управления
(Inversion of Control Containers, IoC-containers).


== Inversion of Control Containers

IoC-container - это фреймворк управляющий объектами и их
зависимостями во время исполнения программы.

Spring был первым _универсальным_ IoC-контейнером с которым я столкнулся
на практике. Чего уж таить, я не сразу проникся заложенными в него
идеями. По-настоящему ощутить всю мощь автоматического связывания
(autowiring) и сопутствующего функционала я смог лишь когда
приложение начали престраивать в соответствии с практиками чистой архитектуры.
Но мы немного забежали вперёд.

Давайте-ка я приведу несколько примеров-аналогов на Питоне, для тех кто не знаком
со Springом.




Прежде чем идти дальше, я хотел бы поделиться с вами опытом


Если вы пользуетесь `pytest` тоЧто такое IoC container


== Hexagonal architecture of Ports and Adapters
